import { z } from 'zod';
import { componentRegistry, ConfigurationError, defineComponent, inputs, outputs, parameters, port, param } from '@shipsec/component-sdk';

const inputSchema = inputs({
  content: port(
    z.string()
      .default('Generated by Artifact Writer component.')
      .describe('Raw text that will be stored in the artifact.'),
    {
      label: 'Content',
      description: 'Text that will be stored inside the artifact.',
      editor: 'textarea',
    },
  ),
});

const parameterSchema = parameters({
  fileName: param(
    z
      .string()
      .min(1, 'File name is required')
      .default('artifact.txt')
      .describe('File name to assign to the saved artifact.'),
    {
      label: 'File Name',
      editor: 'text',
      description: 'File name to use when saving the artifact.',
    },
  ),
  mimeType: param(
    z.string().default('text/plain').describe('Content MIME type. Defaults to text/plain.'),
    {
      label: 'MIME Type',
      editor: 'text',
      description: 'Content MIME type (e.g. text/plain, application/json).',
    },
  ),
  saveToRunArtifacts: param(
    z
      .boolean()
      .default(true)
      .describe('Store the artifact under the current run for quick inspection.'),
    {
      label: 'Save to Run Artifacts',
      editor: 'boolean',
      description: 'Keep a copy in the current run for quick inspection.',
    },
  ),
  publishToArtifactLibrary: param(
    z
      .boolean()
      .default(false)
      .describe('Also publish the artifact to the workspace-wide library.'),
    {
      label: 'Publish to Artifact Library',
      editor: 'boolean',
      description: 'Also publish to the workspace-level library for reuse.',
    },
  ),
});

const outputSchema = outputs({
  artifactId: port(z.string().optional(), {
    label: 'Artifact ID',
    description: 'Identifier returned by the artifact service.',
  }),
  fileName: port(z.string(), {
    label: 'File Name',
    description: 'Name of the artifact file that was written.',
  }),
  size: port(z.number(), {
    label: 'Size',
    description: 'Size of the stored content in bytes.',
  }),
  destinations: port(z.array(z.enum(['run', 'library'])), {
    label: 'Destinations',
    description: 'Destination targets the artifact was stored in.',
  }),
  saved: port(z.boolean(), {
    label: 'Saved',
    description: 'Indicates whether the artifact was persisted.',
  }),
});

const definition = defineComponent({
  id: 'core.artifact.writer',
  label: 'Artifact Writer',
  category: 'output',
  runner: { kind: 'inline' },
  inputs: inputSchema,
  outputs: outputSchema,
  parameters: parameterSchema,
  docs:
    'Writes the provided text content to an artifact using the configured file name and destinations. Useful for testing the artifact pipeline or persisting lightweight diagnostics.',
  ui: {
    slug: 'artifact-writer',
    version: '1.0.0',
    type: 'process',
    category: 'output',
    description: 'Save arbitrary text content as an artifact for the current run and/or the shared library.',
    icon: 'Archive',
    author: {
      name: 'ShipSecAI',
      type: 'shipsecai',
    },
  },
  async execute({ inputs, params }, context) {
    const destinations: Array<'run' | 'library'> = [];
    if (params.saveToRunArtifacts) {
      destinations.push('run');
    }
    if (params.publishToArtifactLibrary) {
      destinations.push('library');
    }

    if (destinations.length === 0) {
      context.logger.info('[ArtifactWriter] No destinations selected; skipping upload.');
      return {
        artifactId: undefined,
        fileName: params.fileName,
        size: Buffer.byteLength(inputs.content ?? ''),
        destinations: [],
        saved: false,
      };
    }

    if (!context.artifacts) {
      throw new ConfigurationError(
        'Artifact service is not available in this execution environment. Ensure the worker is configured with artifact storage.',
        { configKey: 'artifacts' },
      );
    }

    const buffer = Buffer.from(inputs.content ?? '', 'utf-8');
    context.logger.info(
      `[ArtifactWriter] Uploading '${params.fileName}' (${buffer.byteLength} bytes) to ${destinations.join(
        ', ',
      )}`,
    );

    const upload = await context.artifacts.upload({
      name: params.fileName,
      mimeType: params.mimeType ?? 'text/plain',
      content: buffer,
      destinations,
    });

    return {
      artifactId: upload.artifactId,
      fileName: params.fileName,
      size: buffer.byteLength,
      destinations,
      saved: true,
    };
  },
});

componentRegistry.register(definition);

// Create local type aliases for backward compatibility
type Input = typeof inputSchema;
type Output = typeof outputSchema;

export type { Input as ArtifactWriterInput, Output as ArtifactWriterOutput };
