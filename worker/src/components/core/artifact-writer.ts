import { z } from 'zod';
import {
  componentRegistry,
  ConfigurationError,
  defineComponent,
  inputs,
  outputs,
  parameters,
  port,
  param,
} from '@shipsec/component-sdk';

const inputSchema = inputs({
  content: port(
    z
      .any()
      .default('Generated by Artifact Writer component.')
      .describe(
        'Content that will be stored in the artifact. Can be text, JSON, arrays, or any serializable data.',
      ),
    {
      label: 'Content',
      description:
        'Content that will be stored inside the artifact. Accepts any data type - will be serialized to JSON if not already a string.',
      editor: 'textarea',
      allowAny: true,
      reason: 'Artifact writer can accept any serializable data type to be stored as a file.',
    },
  ),
});

const parameterSchema = parameters({
  fileName: param(
    z
      .string()
      .min(1, 'File name is required')
      .default('artifact.txt')
      .describe('File name to assign to the saved artifact.'),
    {
      label: 'File Name',
      editor: 'text',
      description: 'File name to use when saving the artifact.',
    },
  ),
  mimeType: param(
    z.string().default('text/plain').describe('Content MIME type. Defaults to text/plain.'),
    {
      label: 'MIME Type',
      editor: 'text',
      description: 'Content MIME type (e.g. text/plain, application/json).',
    },
  ),
  saveToRunArtifacts: param(
    z
      .boolean()
      .default(true)
      .describe('Store the artifact under the current run for quick inspection.'),
    {
      label: 'Save to Run Artifacts',
      editor: 'boolean',
      description: 'Keep a copy in the current run for quick inspection.',
    },
  ),
  publishToArtifactLibrary: param(
    z.boolean().default(false).describe('Also publish the artifact to the workspace-wide library.'),
    {
      label: 'Publish to Artifact Library',
      editor: 'boolean',
      description: 'Also publish to the workspace-level library for reuse.',
    },
  ),
});

const outputSchema = outputs({
  artifactId: port(z.string().optional(), {
    label: 'Artifact ID',
    description: 'Identifier returned by the artifact service.',
  }),
  fileName: port(z.string(), {
    label: 'File Name',
    description: 'Name of the artifact file that was written.',
  }),
  size: port(z.number(), {
    label: 'Size',
    description: 'Size of the stored content in bytes.',
  }),
  destinations: port(z.array(z.enum(['run', 'library'])), {
    label: 'Destinations',
    description: 'Destination targets the artifact was stored in.',
  }),
  saved: port(z.boolean(), {
    label: 'Saved',
    description: 'Indicates whether the artifact was persisted.',
  }),
});

const definition = defineComponent({
  id: 'core.artifact.writer',
  label: 'Artifact Writer',
  category: 'output',
  runner: { kind: 'inline' },
  inputs: inputSchema,
  outputs: outputSchema,
  parameters: parameterSchema,
  docs: 'Writes any content (text, JSON, arrays, objects) to an artifact. Non-string content is automatically serialized to JSON. Useful for persisting workflow outputs, scan results, or any data.',
  ui: {
    slug: 'artifact-writer',
    version: '1.0.0',
    type: 'process',
    category: 'output',
    description:
      'Save any content (text, JSON, arrays, objects) as an artifact for the current run and/or the shared library.',
    icon: 'Archive',
    author: {
      name: 'ShipSecAI',
      type: 'shipsecai',
    },
  },
  async execute({ inputs, params }, context) {
    const destinations: ('run' | 'library')[] = [];
    if (params.saveToRunArtifacts) {
      destinations.push('run');
    }
    if (params.publishToArtifactLibrary) {
      destinations.push('library');
    }

    // Serialize content to string - if already a string, use as-is; otherwise JSON stringify
    const rawContent = inputs.content;
    let serializedContent: string;
    if (rawContent === undefined || rawContent === null) {
      serializedContent = '';
    } else if (typeof rawContent === 'string') {
      serializedContent = rawContent;
    } else {
      // Serialize arrays, objects, and other types to JSON
      serializedContent = JSON.stringify(rawContent, null, 2);
    }

    if (destinations.length === 0) {
      context.logger.info('[ArtifactWriter] No destinations selected; skipping upload.');
      return {
        artifactId: undefined,
        fileName: params.fileName,
        size: Buffer.byteLength(serializedContent),
        destinations: [],
        saved: false,
      };
    }

    if (!context.artifacts) {
      throw new ConfigurationError(
        'Artifact service is not available in this execution environment. Ensure the worker is configured with artifact storage.',
        { configKey: 'artifacts' },
      );
    }

    const buffer = Buffer.from(serializedContent, 'utf-8');
    context.logger.info(
      `[ArtifactWriter] Uploading '${params.fileName}' (${buffer.byteLength} bytes) to ${destinations.join(
        ', ',
      )}`,
    );

    const upload = await context.artifacts.upload({
      name: params.fileName,
      mimeType: params.mimeType ?? 'text/plain',
      content: buffer,
      destinations,
    });

    return {
      artifactId: upload.artifactId,
      fileName: params.fileName,
      size: buffer.byteLength,
      destinations,
      saved: true,
    };
  },
});

componentRegistry.register(definition);

// Create local type aliases for backward compatibility
type Input = typeof inputSchema;
type Output = typeof outputSchema;

export type { Input as ArtifactWriterInput, Output as ArtifactWriterOutput };
