import { z } from 'zod';
import { componentRegistry, type ComponentDefinition, port, ValidationError } from '@shipsec/component-sdk';

/**
 * Severity levels for security findings
 */
const severitySchema = z.enum(['critical', 'high', 'medium', 'low', 'info']);

/**
 * Schema for a single security finding
 */
const findingSchema = z.object({
  severity: severitySchema,
  title: z.string(),
  description: z.string(),
  cve: z.string().optional(),
  cvss: z.number().optional(),
  proof: z.string().optional(),
  remediation: z.string().optional(),
  references: z.array(z.string()).optional(),
});

/**
 * Schema for report metadata
 */
const metadataSchema = z.object({
  clientName: z.string().optional(),
  projectName: z.string().optional(),
  date: z.string().optional(),
  logo: z.string().optional(),
  reportTitle: z.string().optional(),
  preparedBy: z.string().optional(),
});

/**
 * Schema for scope/targets
 */
const scopeSchema = z.array(z.union([z.string(), z.object({
  target: z.string(),
  type: z.string().optional(),
  description: z.string().optional(),
})]));

/**
 * Template contract schema - defines what a report template looks like
 */
const templateContractSchema = z.object({
  id: z.string(),
  name: z.string(),
  version: z.string(),
  description: z.string().optional(),
  // Template content is stored separately and fetched by ID
  // This component just needs the template reference
});

/**
 * Supported output formats
 */
const outputFormatSchema = z.enum(['pdf', 'html']);

/**
 * Input schema for report generator
 */
const inputSchema = z.object({
  template: z
    .union([
      templateContractSchema,
      z.object({
        id: z.string(),
        version: z.string().optional(),
      }),
    ])
    .describe('Template to use for generating the report. Can be a template object or reference by ID.'),

  // Report data inputs
  findings: z
    .array(findingSchema)
    .optional()
    .default([])
    .describe('Security findings to include in the report.'),

  metadata: z
    .record(z.string(), z.unknown())
    .optional()
    .default({})
    .describe('Report metadata (client name, date, etc).'),

  scope: z
    .array(z.union([z.string(), z.object({
      target: z.string(),
      type: z.string().optional(),
      description: z.string().optional(),
    })]))
    .optional()
    .default([])
    .describe('Scope/targets that were tested.'),

  // Additional data for custom templates
  additionalData: z
    .record(z.string(), z.unknown())
    .optional()
    .default({})
    .describe('Additional data to pass to the template.'),

  // Output options
  format: outputFormatSchema
    .default('pdf')
    .describe('Output format for the report.'),

  fileName: z
    .string()
    .default('report.pdf')
    .describe('Name for the generated report file.'),

  includeBranding: z
    .boolean()
    .default(true)
    .describe('Whether to include ShipSec branding in the report.'),

  // Destination for the report
  destination: z
    .any()
    .optional()
    .describe('Destination adapter configuration. If not provided, saves to run artifacts.'),
});

type Input = z.infer<typeof inputSchema>;

/**
 * Output schema for report generator
 */
const outputSchema = z.object({
  artifactId: z.string().describe('ID of the stored report artifact.'),
  fileName: z.string().describe('Name of the generated report file.'),
  format: outputFormatSchema.describe('Format of the generated report.'),
  size: z.number().describe('Size of the report in bytes.'),
  templateId: z.string().describe('Template ID used to generate the report.'),
  templateVersion: z.string().describe('Template version used.'),
  generatedAt: z.string().describe('ISO timestamp of report generation.'),
});

type Output = z.infer<typeof outputSchema>;

/**
 * Severity color mapping for reports
 */
export const SEVERITY_COLORS: Record<z.infer<typeof severitySchema>, string> = {
  critical: '#DC2626', // red-600
  high: '#EA580C',     // orange-600
  medium: '#CA8A04',   // yellow-600
  low: '#16A34A',      // green-600
  info: '#2563EB',     // blue-600
};

/**
 * Default ShipSec branding HTML
 */
export const SHIPSEC_BRANDING = {
  header: `
    <div style="display: flex; align-items: center; justify-content: space-between; padding: 20px 40px; border-bottom: 2px solid #1f2937;">
      <div style="display: flex; align-items: center; gap: 12px;">
        <svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect width="40" height="40" rx="8" fill="#1f2937"/>
          <path d="M20 10L28 18V28H12V18L20 10Z" stroke="white" stroke-width="2" fill="none"/>
          <circle cx="20" cy="22" r="3" fill="white"/>
        </svg>
        <span style="font-size: 20px; font-weight: 600; color: #1f2937;">ShipSec Studio</span>
      </div>
      <div style="font-size: 12px; color: #6b7280;">Generated by ShipSec Studio</div>
    </div>
  `,
  footer: `
    <div style="padding: 20px 40px; border-top: 1px solid #e5e7eb; display: flex; justify-content: space-between; font-size: 11px; color: #6b7280;">
      <div>Generated by ShipSec Studio - <span class="date"></span></div>
      <div>Confidential - For Authorized Recipients Only</div>
    </div>
  `,
};

/**
 * Default HTML template for pentest reports
 * This is used when no template is specified or as a fallback
 */
export function getDefaultReportHTML(data: {
  findings: z.infer<typeof findingSchema>[];
  metadata: Record<string, unknown>;
  scope: Array<string | { target: string; type?: string; description?: string }>;
}): string {
  const metadata = data.metadata as Record<string, string | undefined>;
  const reportTitle = metadata.reportTitle || 'Penetration Test Report';
  const clientName = metadata.clientName || 'Not specified';
  const date = metadata.date || new Date().toISOString().split('T')[0];
  const preparedBy = metadata.preparedBy || 'ShipSec Security Team';

  // Count findings by severity
  const severityCounts = data.findings.reduce(
    (acc, f) => {
      acc[f.severity] = (acc[f.severity] || 0) + 1;
      return acc;
    },
    {} as Record<string, number>
  );

  const findingsHTML = data.findings.length > 0
    ? data.findings.map((finding, idx) => `
        <div class="finding" style="margin-bottom: 24px; padding: 16px; border-left: 4px solid ${SEVERITY_COLORS[finding.severity]}; background: #f9fafb; border-radius: 0 8px 8px 0;">
          <div style="display: flex; align-items: start; justify-content: space-between; margin-bottom: 12px;">
            <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #1f2937;">
              ${idx + 1}. ${finding.title}
            </h3>
            <span style="padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600; background: ${SEVERITY_COLORS[finding.severity]}; color: white; text-transform: uppercase;">
              ${finding.severity}
            </span>
          </div>
          ${finding.cve ? `<p style="margin: 0 0 8px 0; font-size: 13px; color: #6b7280;"><strong>CVE:</strong> ${finding.cve}</p>` : ''}
          ${finding.cvss ? `<p style="margin: 0 0 8px 0; font-size: 13px; color: #6b7280;"><strong>CVSS:</strong> ${finding.cvss}</p>` : ''}
          <p style="margin: 0 0 12px 0; font-size: 14px; line-height: 1.6; color: #374151;">${finding.description}</p>
          ${finding.proof ? `
            <div style="margin-bottom: 12px;">
              <strong style="font-size: 13px; color: #374151;">Proof:</strong>
              <pre style="margin: 8px 0; padding: 12px; background: #1f2937; color: #e5e7eb; border-radius: 6px; font-size: 12px; overflow-x: auto;">${finding.proof}</pre>
            </div>
          ` : ''}
          ${finding.remediation ? `
            <div>
              <strong style="font-size: 13px; color: #374151;">Remediation:</strong>
              <p style="margin: 8px 0 0 0; font-size: 14px; line-height: 1.6; color: #374151;">${finding.remediation}</p>
            </div>
          ` : ''}
          ${finding.references && finding.references.length > 0 ? `
            <div style="margin-top: 12px;">
              <strong style="font-size: 13px; color: #374151;">References:</strong>
              <ul style="margin: 8px 0 0 0; padding-left: 20px; font-size: 13px;">
                ${finding.references.map(ref => `<li style="margin-bottom: 4px;"><a href="${ref}" style="color: #2563eb;">${ref}</a></li>`).join('')}
              </ul>
            </div>
          ` : ''}
        </div>
      `).join('')
    : '<p style="color: #6b7280; font-style: italic;">No findings were identified during this assessment.</p>';

  const scopeHTML = data.scope.length > 0
    ? data.scope.map(s => {
      const target = typeof s === 'string' ? s : s.target;
      const type = typeof s === 'string' ? undefined : s.type;
      const description = typeof s === 'string' ? undefined : s.description;
      return `
        <tr style="border-bottom: 1px solid #e5e7eb;">
          <td style="padding: 12px; color: #374151;">${target}</td>
          <td style="padding: 12px; color: #6b7280;">${type || '-'}</td>
          <td style="padding: 12px; color: #6b7280;">${description || '-'}</td>
        </tr>
      `;
    }).join('')
    : '<tr><td colspan="3" style="padding: 12px; color: #6b7280; text-align: center;">No scope defined</td></tr>';

  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${reportTitle}</title>
      <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
          line-height: 1.6;
          color: #1f2937;
          background: #ffffff;
        }
        .container { max-width: 900px; margin: 0 auto; padding: 40px; }
        h1 { font-size: 32px; font-weight: 700; margin-bottom: 8px; color: #1f2937; }
        h2 { font-size: 24px; font-weight: 600; margin-top: 32px; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb; }
        h3 { font-size: 18px; font-weight: 600; margin-bottom: 8px; }
        .meta { color: #6b7280; font-size: 14px; margin-bottom: 24px; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px; margin: 24px 0; }
        .summary-card { padding: 16px; border-radius: 8px; text-align: center; }
        .summary-card.critical { background: #fef2f2; border: 1px solid #fecaca; }
        .summary-card.high { background: #fff7ed; border: 1px solid #fed7aa; }
        .summary-card.medium { background: #fefce8; border: 1px solid #fef08a; }
        .summary-card.low { background: #f0fdf4; border: 1px solid #bbf7d0; }
        .summary-card.info { background: #eff6ff; border: 1px solid #bfdbfe; }
        .summary-count { font-size: 32px; font-weight: 700; }
        .summary-label { font-size: 13px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; }
        table { width: 100%; border-collapse: collapse; margin: 16px 0; }
        th { text-align: left; padding: 12px; background: #f9fafb; border-bottom: 2px solid #e5e7eb; font-weight: 600; font-size: 13px; color: #374151; }
        td { padding: 12px; border-bottom: 1px solid #e5e7eb; }
        @media print {
          body { print-color-adjust: exact; -webkit-print-color-adjust: exact; }
          .page-break { page-break-before: always; }
        }
      </style>
    </head>
    <body>
      ${SHIPSEC_BRANDING.header}

      <div class="container">
        <h1>${reportTitle}</h1>
        <p class="meta">
          <strong>Client:</strong> ${clientName} &nbsp;|&nbsp;
          <strong>Date:</strong> ${date} &nbsp;|&nbsp;
          <strong>Prepared by:</strong> ${preparedBy}
        </p>

        <h2>Executive Summary</h2>
        <p style="margin-bottom: 16px;">
          This security assessment was conducted to identify vulnerabilities and security weaknesses
          in the specified targets. A total of <strong>${data.findings.length} findings</strong> were identified.
        </p>

        <div class="summary-grid">
          <div class="summary-card critical">
            <div class="summary-count" style="color: ${SEVERITY_COLORS.critical}">${severityCounts.critical || 0}</div>
            <div class="summary-label">Critical</div>
          </div>
          <div class="summary-card high">
            <div class="summary-count" style="color: ${SEVERITY_COLORS.high}">${severityCounts.high || 0}</div>
            <div class="summary-label">High</div>
          </div>
          <div class="summary-card medium">
            <div class="summary-count" style="color: ${SEVERITY_COLORS.medium}">${severityCounts.medium || 0}</div>
            <div class="summary-label">Medium</div>
          </div>
          <div class="summary-card low">
            <div class="summary-count" style="color: ${SEVERITY_COLORS.low}">${severityCounts.low || 0}</div>
            <div class="summary-label">Low</div>
          </div>
          <div class="summary-card info">
            <div class="summary-count" style="color: ${SEVERITY_COLORS.info}">${severityCounts.info || 0}</div>
            <div class="summary-label">Info</div>
          </div>
        </div>

        <div class="page-break"></div>

        <h2>Detailed Findings</h2>
        ${findingsHTML}

        <div class="page-break"></div>

        <h2>Scope</h2>
        <table>
          <thead>
            <tr>
              <th>Target</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            ${scopeHTML}
          </tbody>
        </table>

        <h2>Methodology</h2>
        <p style="color: #6b7280;">
          This assessment was conducted following industry-standard penetration testing methodologies
          including OWASP Testing Guide, PTES, and OSSTMM. Testing included automated vulnerability
          scanning, manual testing, and validation of findings.
        </p>
      </div>

      ${SHIPSEC_BRANDING.footer}

      <script>
        // Update date in footer
        document.querySelector('.date').textContent = new Date().toLocaleDateString();
      </script>
    </body>
    </html>
  `;
}

/**
 * Report Generator Component
 *
 * Generates PDF/HTML reports from template and data.
 *
 * TODO: Integrate with Puppeteer component for PDF generation
 * TODO: Fetch templates from database/storage
 * TODO: Support Preact/HTM template rendering
 */
const definition: ComponentDefinition<Input, Output> = {
  id: 'core.report.generator',
  label: 'Report Generator',
  category: 'output',
  runner: { kind: 'inline' },
  inputSchema,
  outputSchema,
  docs:
    'Generate professional security reports from template and data. Supports PDF and HTML output formats with ShipSec branding.',
  metadata: {
    slug: 'report-generator',
    version: '1.0.0',
    type: 'process',
    category: 'output',
    description: 'Generate PDF/HTML reports from workflow data using templates.',
    icon: 'FileText',
    author: {
      name: 'ShipSecAI',
      type: 'shipsecai',
    },
    inputs: [
      {
        id: 'template',
        label: 'Template',
        dataType: port.json(),
        required: true,
        description: 'Report template to use. Can be a template object or template ID.',
      },
      {
        id: 'findings',
        label: 'Findings',
        dataType: port.list(port.json()),
        description: 'Security findings to include in the report.',
      },
      {
        id: 'metadata',
        label: 'Metadata',
        dataType: port.json(),
        description: 'Report metadata (client name, date, logo, etc).',
      },
      {
        id: 'scope',
        label: 'Scope',
        dataType: port.list(port.json()),
        description: 'Targets/assets that were tested.',
      },
    ],
    outputs: [
      {
        id: 'artifactId',
        label: 'Artifact ID',
        dataType: port.text(),
        description: 'ID of the stored report artifact.',
      },
      {
        id: 'report',
        label: 'Report',
        dataType: port.contract('shipsec.file.v1'),
        description: 'Generated report file reference.',
      },
    ],
    parameters: [
      {
        id: 'template',
        label: 'Template',
        type: 'json',
        description: 'Template object with id, name, version.',
      },
      {
        id: 'format',
        label: 'Format',
        type: 'select',
        default: 'pdf',
        options: [
          { label: 'PDF', value: 'pdf' },
          { label: 'HTML', value: 'html' },
        ],
        description: 'Output format for the report.',
      },
      {
        id: 'fileName',
        label: 'File Name',
        type: 'text',
        default: 'report.pdf',
        description: 'Name for the generated report file.',
      },
      {
        id: 'includeBranding',
        label: 'Include ShipSec Branding',
        type: 'boolean',
        default: true,
        description: 'Whether to include ShipSec header and footer.',
      },
    ],
  },

  async execute(params, context) {
    const templateId = typeof params.template === 'object' && 'id' in params.template
      ? params.template.id
      : 'default';

    const templateVersion = typeof params.template === 'object' && 'version' in params.template && params.template.version
      ? params.template.version
      : '1.0.0';

    context.logger.info(
      `[ReportGenerator] Generating report using template: ${templateId} v${templateVersion}`
    );

    // Build report data
    const reportData = {
      findings: params.findings ?? [],
      metadata: params.metadata ?? {},
      scope: params.scope ?? [],
      ...params.additionalData,
    };

    // Generate HTML
    // TODO: In full implementation, fetch template from DB and render with Preact/HTM
    const html = getDefaultReportHTML(reportData);

    let buffer: Buffer;
    let mimeType: string;

    if (params.format === 'pdf') {
      // TODO: Use Puppeteer component to generate PDF
      // For now, store HTML and note that PDF generation is pending
      context.logger.warn(
        '[ReportGenerator] PDF generation pending Puppeteer integration. Storing HTML instead.'
      );

      // Temporary: store HTML with .pdf extension (will be replaced once Puppeteer is ready)
      buffer = Buffer.from(html, 'utf-8');
      mimeType = 'text/html';
    } else {
      buffer = Buffer.from(html, 'utf-8');
      mimeType = 'text/html';
    }

    context.logger.info(
      `[ReportGenerator] Generated ${buffer.byteLength} bytes of ${params.format}`
    );

    // Store the report
    // If destination is provided, use destination adapter
    // Otherwise, save to run artifacts
    let artifactId: string | undefined;

    if (params.destination) {
      // TODO: Use destination adapter when provided
      context.logger.info('[ReportGenerator] Saving to destination adapter...');
      // This will be implemented once destination adapter integration is ready
    } else {
      // Save to run artifacts using the storage service
      try {
        const uploadResult = await context.storage.uploadFile(buffer, {
          filename: params.fileName,
          mimeType: params.format === 'pdf' ? 'application/pdf' : 'text/html',
          metadata: {
            templateId,
            templateVersion,
            format: params.format,
            generatedAt: new Date().toISOString(),
            findingsCount: reportData.findings.length,
          },
        });
        // Handle both string result and object result
        artifactId = typeof uploadResult === 'string' ? uploadResult : uploadResult.artifactId;
        context.logger.info(`[ReportGenerator] Saved report as artifact: ${artifactId}`);
      } catch (error) {
        context.logger.error(`[ReportGenerator] Failed to save report: ${error}`);
        throw new ValidationError('Failed to save report artifact.', {
          fieldErrors: { storage: ['Storage upload failed'] },
        });
      }
    }

    return {
      artifactId: artifactId ?? '',
      fileName: params.fileName,
      format: params.format,
      size: buffer.byteLength,
      templateId,
      templateVersion,
      generatedAt: new Date().toISOString(),
    };
  },
};

componentRegistry.register(definition);

export type { Input as ReportGeneratorInput, Output as ReportGeneratorOutput };
